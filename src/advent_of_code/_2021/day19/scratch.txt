




;;             Unshared Beacons Set

;; Per the instructions' rule that at least 12 beacons be common to two reports
;; in some of their orientations in order to qualify as overlapping, then any
;; reports left with having no overlap with any other, their respective coordinates
;; must be exclusive. Also, since no overlap can be determined it is also impossible
;; to find the unshared report's orientation and beacons' position relative to s0,
;; which contradicts the premise that the entire beacon space can be reconstructed
;; with the 12-beacon overlap rule. Therefore the Unshared Beacons Set C in the
;; algorithm has to be empty. We will keep it around for verification purposes. 

;;             Shared Beacons Pairs are connected 

;; Suppose that in set B there are some pairs (sX sY) the ids of which are not
;; found in any other pair in B, with X,Y not= 0; then sX and sY are left with  
;; beacons' positions that can't be determined w.r.t. s0, a contradiction to the
;; guidance that the beacons' space can be reconstructed. Therefore all report 
;; pairs in B form a directed connected graph where each edge goes from pair 
;; (sX sY) to (sU sW) whenever Y = U. 

;; Step 7: Order the pairs from set B by the scanner id of the first element of
;;         each pair. 
;;
;; Step 8: For each such ordered pair, convert the second sets to the first
;;         by adding the delta of the second set's origin

;; (At this point, all of the points in each pair are in scanner 0's coordinate
;; system.)

;; Step 9: The result is the union over all point sets from each pair  

#_(defn assemble [input]
  (let [id-pairs (sorted-combo (-> input count range))
        report-pairs (->> id-pairs
                           (map (fn [[from to]]
                                  [(nth input from) (nth input to)])))
        overlaps (->> report-pairs
                      (map (fn [[[id-1 beacons-1] [id-2 beacons-2]]]
                             (->> beacons-2 transform
                                  (keep #(when-let [m (overlap? beacons-1 %)]
                                           (-> m 
                                               (assoc :from-id id-1)
                                               (assoc :to-id id-2))))))))]
    overlaps))



;;     ...B..        ...B..        ...B..
;;     B....S        B.....        B....S
;;     ....B.        ....B.        ....B.
;;     S.B...        S.B...        


;;        ...B...B
;;        B....S..
;;        .B..B...
;;        S.B.....
;;        ......
;;        ...B..
;;                                 

;;    




#_(defn matching-pairs
  "Yields point-to-point equivalence tuples using matches' 
  individual segments ordering."
  #_([matches]
   (->> matches
        (sequence 
         (comp
          (mapcat (fn [[[a1 b1] [a2 b2]]]
                    [[a1 a2] [b1 b2]]))
          (distinct)))))
  #_([segs1 segs2]
   (->> (for [[a1 b1 :as seg1] segs1
              [a2 b2 :as seg2] segs2
              :when (equivalent? seg1 seg2)]
          [[a1 a2] [b1 b2]])
        (sequence 
         (comp (mapcat identity) (distinct))))))

#_(defn consistent?
  ([s1 s2 delta m1 m2 & [max-distance]]
   (let [max-distance (or max-distance *visibility*) 
         s2-origin delta 
         e1 (-> s1 set (difference (set m1)))   ;; exclusive to s1
         e2 (->> s2 set (#(difference % (set m2)))  ;; " to s2, converted to s1 coords.
                 (map (partial shift-by delta)) set)]
     (and (->> e2 (every? #(not (delta-within? max-distance [0 0 0] %))))
          (->> e1 (every? #(not (delta-within? max-distance s2-origin %))))))))

;; (defn closer=
  ;; "Returns true if p1 is closer to the origin, or p1 = p2"
  ;; [p1 p2]
  ;; (-> (sort p1 p2) first (= p1)))

;; (defn closer
  ;; [p1 p2] (and (not= p1 p2) (closer= p1 p2)))

;; (defn further= [p1 p2]
  ;; (not (closer p1 p2)))



#_(defn overlap?
  "segs1 segs2 are colls of segments in different coordinate systems.
  Yields a tuple [matches delta] where matches are tuples of
  [p1 p2] equivalent points between s1 and s2, if they overlap;
  nil otherwise.
  "
[s1 s2 & [threshold testing?]]
  (let [threshold (or threshold 12) 
        segs1 (if (u/segment? (first s1))
                s1 
                (u/sorted-combo s1))
        segs2 (u/sorted-combo s2)
        matches (matching-pairs segs1 segs2)
        kount (->> matches (mapcat first) distinct count)]
    (when (<= threshold kount)
      (let [[m1 m2] (->> matches 
                         ((juxt (partial sequence 
                                         (comp (mapcat first) (distinct)))
                                (partial sequence 
                                         (comp (mapcat second) (distinct))))))
            delta (apply <-delta (->> matches first (map first)))]
        (when (consistent? s1 s2 delta m1 m2)
          (if testing?
            [(equivalence matches) delta]
            {:delta delta
             :anchor-segments segs1}))))))



#_(defn xforms [p]
  (->>
   (for [[x y z] (c/permutations p)
         :let [x' (- x) y' (- y) z' (- z)]]
     [[x y z] 
      [x' y z] [x' y' z] [x' y' z']])
   (mapcat identity)))

(def xforms-2 
  (->>
   (for [[x y z] (c/permutations (range 3))
         :let [nx #(nth % x)
               ny #(nth % y)
               nz #(nth % z)]
         :let [nx' (comp - nx)
               ny' (comp - ny)
               nz' (comp - nz)]]
     [(fn [p] [(nx p) (ny p) (nz p)])
      (fn [p] [(nx' p) (ny p) (nz p)])
      (fn [p] [(nx' p) (ny' p) (nz p)])
      (fn [p] [(nx' p) (ny' p) (nz' p)])])
   (mapcat identity)))


#_(def transforms-2
  (for [[ax1 ax2 ax3] (c/permutations [:x :y :z])
        period (range 4)]
    (partial rotate axis period)))

(defn transform-point-2 [p]
  (->> transforms-2
       (map #(% [p]))
       (map first)))

#_(defn xform [xs]
  (->> xforms-2
       (map #(mapv % xs))))

#_(def transforms-2
  (let [periods (range 4)]
    (for [xp periods
          yp periods
          zp periods]
      (fn [point]
        (->> point
             (rotate-1 :x xp)
             (rotate-1 :y yp)
             (rotate-1 :z yp))))))

#_(defn transform-point-2 [p]
  (->> transforms-2
       (map #(% p))
       distinct))

        y-neg (->> (range 4)
                   (map #(comp (fn [loc] 
                                 (->> loc (t/rotate-1 :z 3)
                                      (t/rotate-1 :y 2)))
                               (x-rot %))))
